{"meta":{"title":"这里该有个GhosKno","subtitle":"一地鸡毛里写博客","description":null,"author":"GhosKno","url":"http://ghoskno.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2017-03-30T10:18:41.000Z","updated":"2018-04-23T03:55:48.000Z","comments":false,"path":"/404.html","permalink":"http://ghoskno.github.io//404.html","excerpt":"","text":""},{"title":"分类","date":"2017-03-30T10:00:43.000Z","updated":"2018-04-23T03:55:48.000Z","comments":false,"path":"categories/index.html","permalink":"http://ghoskno.github.io/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2017-03-30T10:14:59.000Z","updated":"2018-04-23T03:55:48.000Z","comments":false,"path":"tags/index.html","permalink":"http://ghoskno.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ABC-CNN阅读笔记","slug":"ABC-CNN","date":"2018-04-29T07:50:33.000Z","updated":"2018-04-29T12:20:22.000Z","comments":true,"path":"2018/04/29/ABC-CNN/","link":"","permalink":"http://ghoskno.github.io/2018/04/29/ABC-CNN/","excerpt":"前言本篇记录的是关于2015年论文ABC-CNN: An Attention Based Convolutional Neural Network for Visual Question Answering的阅读笔记。 问题背景 视觉问答（Visual Question Answering，VQA），是一种涉及计算机视觉和自然语言处理的学习任务。这一任务的定义如下： A VQA system takes as input an image and a free-form, open-ended, natural-language question about the image and produces a natural-language answer as the output。 翻译为中文：一个VQA系统以一张图片和一个关于这张图片形式自由、开放式的自然语言问题作为输入，以生成一条自然语言答案作为输出。简单来说，VQA就是给定的图片进行问答。","text":"前言本篇记录的是关于2015年论文ABC-CNN: An Attention Based Convolutional Neural Network for Visual Question Answering的阅读笔记。 问题背景 视觉问答（Visual Question Answering，VQA），是一种涉及计算机视觉和自然语言处理的学习任务。这一任务的定义如下： A VQA system takes as input an image and a free-form, open-ended, natural-language question about the image and produces a natural-language answer as the output。 翻译为中文：一个VQA系统以一张图片和一个关于这张图片形式自由、开放式的自然语言问题作为输入，以生成一条自然语言答案作为输出。简单来说，VQA就是给定的图片进行问答。 正文本文中会明显区别图像特征(image feature) 和 视觉特征(visual feature) 两词 Abstract Note摘要部分中，论文阐述的重点是针对VQA问题，一般方法是增强对与问题相关的图像区域的关注(quesion-quided attention)，ABC-CNN中提出使用基于注意力模型的可配置卷积神经网络(attention based configurable convolution neural network)去提取输入图像的关注区域。 ABC-CNN determinesan attention map for an image-question pair by convolvingthe image feature map with configurable convolutionalkernels derived from the question’s semantics. 即ABC-CNN的可配置卷积 k 核由输入的question的问题语义(question’s semantics)驱动和配置，从输入的image中提取image feature map并将其与卷积核 k 进行卷积操作，通过卷积的结果得到对应的输入image-question pair对应的attention map。 Introduction Note该部分提出的几个重点只要是： 使用ABC-CNN作为一个统一的框架整合VQA问题中的视觉和语义信息。 use ABC-CNN as a unified framework to integrate the visual and semantic infomation for VQA. 整个ABC-CNN的实现思路是由问题驱动，寻找关注区域，即通过输入的问题，应用注意力模型寻找输入图片中的关注区域，提取特征并进行进一步的学习。 ABC-CNN的组成为四个部分：vision part, question understand part, answer generation part, attention extraction part/vision and question understanding part。其中各个部分的特点为： vision part：使用CNN从图像中提取visual features，提取空间特征图(spatial features map)而不是提取单独的全局视觉特征(single global visual feature) question understand part： 该部分使用LSTM模型[1]获得问题的嵌入(question embeddings[2]) answer generation part: 使用简单的多类分类器生成answer ABC-CNN模型的核心是将提取得到的 question-guided attention infomation 表现为 question-guided attention map。实现的方法是将输入的question从semantic space 映射到 isual space得到question embedding，再使用question embedding 配置卷积核 k ，通过 k 与image卷积操作得到question-guided attention map It(question-guided attention map) is is achieved via a configurable convolutional neural network,where the convolutional kernels are generated by projecting the question embeddings from the semantic space into the visual space. ABC-CNN认为得到的卷积核 k 与由question语义决定的视觉信息有相关或一致关系 question-guided attention map反映的是image中各区域对目标answer的重要程度。可用于计算图中各区域的空间权重(spatially weight)，过滤图片image中与问题无关的区域/噪音 个人对于这部分的一些疑问 如何得到question embeddings,因为对NLP相关内容了解的不深入，对如何通过问题的嵌入得到question在问题语义空间到视觉特征空间的映射存疑 对于得到的卷积核 k 是否能有效表征特定对象的 visual features 存疑 Related-Work-Note这部分主要介绍了VQA问题与图像描述问题的背景、注意力模型的主要思想和可配置卷积神经网络。 Attention models这部分介绍了attention model在从图像中提取特征的方法，即使用RNN从输入image中提取一系列提议区域(proposal region)，通过从decoding LSTM 输出的隐藏状态和从提议区域中提取的视觉特征学习得到需要的attention weights Attention Based Configurable CNN NoteABC-CNN模型的核心是attention extraction part，卷积核 k 将与图像特征(image features)相作用得到question-guided attention ma，其中卷积核 k 能表征question所需的视觉特征 Attention Extraction 卷积核 k $$k = σ(W_{sk}s + b_k), σ(x) = \\frac{1}{1 + e−x}$$ 其中σ为sigmoid函数，s为question中对应对象的语义特征信息 question-guided attention map m $$m_{ij} = P(ATT_{ij}|I,s) = \\frac{e^{z_{ij}}}{\\sum_i\\sum_j e^{z_{ij}}} ， z = k * I$$ 其中I为图像特征(image features) Question Understanding $$i_t = \\sigma(W_{vi}v_t + W_{hi}h_{t-1} + b_i)$$ $$f_t = \\sigma(W_{vf}v_t + W_{hf}h_{t-1} + b_f)$$ $$o_t = \\sigma(W_{vo}v_t + W_{ho}h_{t-1} + b_o)$$ $$g_t = \\phi(W_{vg}v_t + W_{hg}h_{t-1} + b_g)$$ $$c_t = f_t\\odot c_{t-1} + v_i\\odot g_t$$ $$h_t = o_t \\odot \\phi(c_t)$$ 其中 $\\phi$为hyperbolic tangent function LSTM的输入是question q question q 的语言信息 s 通过对LSTM的输出 h 学习得到 在此附上个人理解该部分的另一种形式的数据图 Image Feature Extraction该部分主要说明如何对输入的image进行处理得到image features 操作方法是将输入的WHD图片分割为NN的栅格区域，对每个栅格区域提取特征得到最后NN*D的image feature map Answer Generation 这部分的多类分类器(mutil-class classifier)基于三个输入： 原始图像特征图 I (original image feature map) 密集问题嵌入 s (dense question embedding) 注意力权重特征图 I’ (attention weighted feature map) 为了避免过拟合，该部分还使用1*1的卷积操作使 I’ 的通道数减少，得到$I_r$用于计算最后结果answer 相关公式 $$I’_i = I_i \\odot m$$ $$h = g(W_{ih}I + W_{rh}I_r + W_{sh}S + b_h)$$ 其中 $m$为question-guided attention map $I’$为得到的attention weighted feature map $g(.)$为element-wise scaled hyperbolic tangent function:$g(x) = 1.7159\\cdot tanh(\\frac{2}{3}x)$ h 为question-image pair提取的最终特征(final projected feature) 多类分类器使用softmax作为计算方法 引用内容 LSTM-长短期记忆模型 通俗解释embedding 结语初学深度学习，如果有发现文中错误的地方，欢迎斧正","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://ghoskno.github.io/categories/深度学习/"}],"tags":[{"name":"Paper Note","slug":"Paper-Note","permalink":"http://ghoskno.github.io/tags/Paper-Note/"},{"name":"VQA","slug":"VQA","permalink":"http://ghoskno.github.io/tags/VQA/"},{"name":"machine learning","slug":"machine-learning","permalink":"http://ghoskno.github.io/tags/machine-learning/"},{"name":"CNN","slug":"CNN","permalink":"http://ghoskno.github.io/tags/CNN/"}]},{"title":"分治法实现循环赛算法笔记","slug":"roundmatch","date":"2017-04-11T10:07:25.000Z","updated":"2018-04-23T03:55:48.000Z","comments":true,"path":"2017/04/11/roundmatch/","link":"","permalink":"http://ghoskno.github.io/2017/04/11/roundmatch/","excerpt":"前言没有前言，rt 正文上周算法设计课的老师布置了这个作业，完成了之后就打算顺便记录下来，以后也会陆续放一些算法设计课的作业和笔记。","text":"前言没有前言，rt 正文上周算法设计课的老师布置了这个作业，完成了之后就打算顺便记录下来，以后也会陆续放一些算法设计课的作业和笔记。 题目 设有n个运动员要进行网球循环赛。设计一个满足下列条件的比赛日程表： 每个选手必须与其他n-1个选手各赛一次 每个选手一天只能比赛一次 当n是偶数时，循环赛进行n-1天 当n是奇数时，循环赛进行n天 简单情况这个题目要求n没有限制，其实是有一点难度的，我们可以先考虑一种简单的情况，限制$n=2^k$.这样在进行二分实现的时候，可以均匀划分，然后通过对子问题的解直接复制，可以容易的构造出原问题的解，如图 容易发现，在$n=2^k$的情况下，将子问题的解直接复制到対角问题就可以直接得到原问题的解。 进一步理解问题，可以发现，其实对能够直接复制子问题到对角的情况的限制并不是原问题的规模一定满足是2的k次冪，而是满足原问题与子问题的规模都是偶数，换句话说，只要原问题能够分割为两个规模大小相等且子问题的规模为偶数，就可以将两个子问题的解通过复制得到原问题的解。 还有一个值得注意的地方，当原问题及其子问题均为偶数规模时，两个子问题可以看作镜像关系，考虑上图左半部分，将其继续分割为两部分，可以看作原问题[1:8]分解为[1:4]和[5:8]两个子问题，子问题的规模为4,可以通过将子问题[1:4]中的排列，每一位加上4得到另一个子问题的解。姑且将这种关系理解为镜像关系（规模为2n的问题中，i与i+n互为镜像，i&lt;=n）吧。 先贴上限制情况的代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int arrange (int** arr,int len)&#123; if(len == 1)&#123; //规模为1，置初值 arr[1][1] = 1; return 0; &#125; arrange(arr,len / 2); //扫描子问题[1:len/2][1:len/2] for (int i = 1; i &lt;= len/2; i++)&#123; for (int j = 1; j &lt;= len / 2; j++)&#123; //完成对镜像问题和对角位置的复制 arr[i][j + len / 2] = arr[i + len / 2][j] = arr[i][j] + len / 2; arr[i + len / 2][j + len / 2] = arr[i][j]; &#125; &#125; return 0;&#125;int main()&#123; int k = 0; cout &lt;&lt; \"input num of player: \"; cin &gt;&gt; k; int **arr = new int *[k + 1]; for (int i = 0; i &lt;= k; i++) arr[i] = new int[k + 1]; memset(arr, 0, sizeof(arr)); arrange(arr, k); for (int i = 1; i &lt;= k; i++)&#123; for (int j = 1; j &lt;= k;j++)&#123; cout &lt;&lt; arr[i][j]; cout &lt;&lt; (j == 1 ? \": \" : \" \"); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 这段代码要求传入原问题规模严格为2的n次冪，否则程序应该很可能大概率会崩掉，不过不重要不重要。。经过上面的分析，理解这段代码应该是没有太大问题的，这里就不过多赘述了。 完整情况上面的讨论有严格的限制条件，现在来讨论无限制情况下，如何利用上面的分析结果完成循环赛的安排。这里分别讨论博主解决问题时想到的几种思路。 第0种思路考虑分解原问题过程中，如果遇到原问题的规模为奇数$2k-1$，则求解问题规模为$2k$的问题，进一步将其分割为两个规模为$k$的子问题。如果按照上面的讨论，将其简单拼接，得到的原问题的解就会超过要求的$2k-1$，读者可自行用规模为5的原问题代入验证。 第1种思路通过对第一种思路的思考，可以知道，面对原问题或子问题为奇数的情况不能简单应用复制子问题和镜像问题的解，需要做特别处理。具体处理奇数规模的办法博主最后还是没想出来，但是在网上找到了解法，最后看了几遍代码，感觉挺有道理的，但是数学功底不够，没法完全证明该方法是对的。接下来的讨论就是对网上找到的处理方法的分析。 抄来的思路 首先从解决原问题开始 如果原问题规模是偶数2k，就递归分治求解原问题一半规模的子问题 如果原问题规模是奇数2k-1，就改为求解规模为2k的原问题（称为凑偶后的原问题），递归求解规模为k的子问题，求解过程中引入编号为2k的虚选手 对于子问题而言，原问题和凑偶的原问题等价 注意，虚选手是对应当前子问题和其原问题而言 子问题的递归求解结束后，开始通过对子问题的解合并处理得到原问题的解 若子问题的规模为偶数2k，那么不存在引入虚选手的情况，只需要如简单情况中，对子问题[1:k]进行直接复制即可 若子问题的规模为奇数(2k-1)，则对应原文题规模为4k-2,此时对于原问题而言，编号2k的选手为需要忽略的虚选手 区别处理的方法是按顺序取余（下文具体讲） 觉得上面讲的比较抽象的话，可以看下面的示意图，以规模为6的原问题为例 图1为规模为6的原问题（红色部分仅为坐标，无意义），此时传入规模为3的子问题进行求解，如图2 规模为3时，需要凑偶为规模为4的原问题，接着对规模为2的子问题求解，如图3 得到规模为2的问题的解后，应用简单情况的做法，将图3中绿色部分的解复制得到图4中黄色部分。黄色部分与绿色部分即为问题规模为4的问题的解。其中编号4的选手为虚选手，即图中标x位置为额外引入 得到规模为4的子问题的解后（图5），对于规模为6的原问题需要解决对剩余部分的填充。 对于规模为6的原问题，分割所得的两个规模为3的子问题，在简单情况中，[1:3]和[4:6]还是互为镜像的两部分，可使用复制的镜像元素的方法覆盖[4:6][1:3]区域，如图6 接着对之前引入的虚选手进行消除，对第i列的x位置，填入选手i的镜像选手如第一天（蓝色第二列），在蓝色第三行x中填入3的镜像选手6,在蓝色第六行x中填入6的镜像选手3。如图7 最后需要解决剩余两列的安排，经过前面的分析可以知道，对于规模为2(2k-1)的问题，i(i&lt;=2k-1)号选手与1~2k-1位选手及其镜像选手(i+2k-1)的比赛已经在前(2k-1)天安排完。意味着，对于第i位选手，在剩余的第2k~2(2k-1)-1天需要安排其与2k～2(2k-1)中除去i的镜像选手的2k-2位选手的比赛。代入规模为6,即第1～3号选手之间的比赛与其中任一选手与其镜像选手的比赛已在前三天安排完毕，1～3号选手中每人需要与4～6号选手中除去对应镜像选手后剩余两位选手比赛。 对剩余两位选手的比赛就需要用顺序取余的办法安排。对于i(i&lt;=2k-1)号选手，令其在第2k天与其镜像选手的下一顺位选手{i+[2k-1]+1)%(2k-1) + (2k-1)}比赛，以此类推。 对第1～2k-1位选手的剩余比赛安排后，如图8绿色部分。最后再将该绿色部分复制到下半部分对应镜像选手中即可得到规模为6的原问题的解（最后一张图就不放啦） 贴上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;void arrange(int** arr,int len)&#123; if (len == 1)&#123; arr[1][1]=1; return ; &#125; if(len&amp;1) len++; //len为奇数，转化为求解len+1的情况 int half_len=len/2; arrange(arr, half_len); //已完成规模为half_len的排列，即矩阵[1：half_len][1：half_len+1]，表示对half_len位选手在第2～half_len天内的安排 for(int i=1;i&lt;=half_len;i++) for(int j=1;j&lt;=half_len+1;j++)&#123; if(arr[i][j]&gt;half_len)&#123; //当前位置为第i位选手对阵第half_len+1号选手（虚选手），表示该位置对i选手空闲 arr[i+half_len][j]=i; //对当天的两个空位进行填补，由于矩阵[half_len+1:len][1:half_len+1]为[1:half_len][1:half_len+1]的镜像 arr[i][j]=i+half_len; //可使互为镜像的两个选手在当天（第1-half_len天内空闲的一天）比赛 int c=i+half_len+1; //c为与i为镜像的选手的下一顺位选手，i与其镜像选手的比赛在第1～half_len天已安排 for(int k=half_len+2;(half_len&amp;1)&amp;&amp;k&lt;=len;k++,c++)&#123; //k为[half_len+2:len]循环，安排i选手与其他非镜像选手的比赛 if(c==i+half_len) c++; //若c为当前排列选手的镜像选手，则按顺位取下一位选手 if(c&gt;len) c-=half_len; //对t在范围[half_len+1:len]中取余 arr[i][k]=c; arr[c][k]=i; &#125; &#125; else&#123; //当前与第i号选手比赛的是1～half_len号，互不为镜像选手 arr[i+half_len][j]=arr[i][j]+half_len; //复制第i位选手的安排成为其镜像选手的比赛安排 if((half_len%2==0)||half_len==1)&#123; //对于子规模为偶数的情况，复制子问题[1:half_len][1:half_len]至[1:len][1:len] arr[i+half_len][j+half_len]=arr[i][j]; arr[i][j+half_len]=arr[i+half_len][j]; &#125; &#125; &#125;&#125;int main()&#123; int k; char blank = 'x'; cout &lt;&lt; \"input num of player: \"; cin &gt;&gt; k; int **arr = new int *[k + 2]; for (int i = 1; i &lt;= k+1; i++) arr[i] = new int[k + 2]; memset(arr,0,sizeof(arr)); if(k&amp;1) arrange(arr, k + 1); else arrange(arr, k); for (int i = 1; i &lt;= k; i++) &#123; for(int j=1;j&lt;=k+(k&amp;1);j++) &#123; if(arr[i][j]&gt;k) cout &lt;&lt; 'x'; else cout &lt;&lt; arr[i][j]; cout &lt;&lt; (j == 1 ? \": \" : \" \"); &#125; cout&lt;&lt;endl; &#125;&#125; 结语打算把这篇博客当作实验报告交上去hhh","categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"http://ghoskno.github.io/categories/算法笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ghoskno.github.io/tags/JavaScript/"},{"name":"算法设计","slug":"算法设计","permalink":"http://ghoskno.github.io/tags/算法设计/"}]},{"title":"Promise简单实现原理","slug":"promise","date":"2017-04-03T09:22:22.000Z","updated":"2018-04-23T03:55:48.000Z","comments":true,"path":"2017/04/03/promise/","link":"","permalink":"http://ghoskno.github.io/2017/04/03/promise/","excerpt":"最近看了几篇讲解Js实现Promise的原理的文章，弄懂了以前没懂的一些东西，今天也稍稍整理一下","text":"最近看了几篇讲解Js实现Promise的原理的文章，弄懂了以前没懂的一些东西，今天也稍稍整理一下 前言不是很懂怎么写前言，Fork（抄袭）一段好了 随着浏览器端异步操作复杂程度的日益增加，以及以 Evented I/O 为核心思想的 NodeJS 的持续火爆，Promise、Async 等异步操作封装由于解决了异步编程上面临的诸多挑战，得到了越来越广泛的应用。本文旨在剖析 Promise 的内部机制，从实现原理层面深入(点到为止地)探讨 — 美团点评技术团队 spring 本文的参考资料是 剖析 Promise 之基础篇 Promise/A+ 尤其是剖析 Promise 之基础篇，希望大家阅读本文之前先看看这篇文章。本文的叙述模式主要是讲解上文中的小细节和个人整理，适合对Promise不大理解的小白食用。 正文基础实现先贴一段引文中promise基础实现的代码12345678910111213141516171819202122232425262728293031323334353637/********* 例1 ***********/function getUserId() &#123; return new Promise(function (resolve) &#123; // 异步请求 Y.io('/userid', &#123; on: &#123; success: function (id, res) &#123; resolve(JSON.parse(res).id); &#125; &#125; &#125;); &#125;);&#125;getUserId().then(function (id) &#123; // do sth with id&#125;);/********* promise基础实现 ***********/function Promise(fn) &#123; var value = null, deferreds = []; this.then = function (onFulfilled) &#123; deferreds.push(onFulfilled); &#125;; function resolve(value) &#123; deferreds.forEach(function (deferred) &#123; deferred(value); &#125;); &#125; fn(resolve);&#125; 引文中例一的代码对于对promise了解不多的同学来说，可能看的云里雾里，所以我把对应的promise实现贴在一起，方便讲解。 getUserId方法被调用后，返回一个Promise对象，而在getUserId方法中返回的Promise接收了一个function参数，这个传入的方法内部会执行getUserId方法需要执行的主体功能，如例一中的IO操作。 当getUserId的主体功能完成后，需要触发下一步的函数，可以看到success状态后，执行resolve方法，传入相应参数即用户ID，完成触发。 这里可能就会有人对resolve方法有些疑惑，觉得这个函数出现的有点突然。其实上一条已经从功能上简单叙述了resolve方法的作用，要理解resolve具体的作用原理我们需要看看Promise对象的实现代码。Promise对象接受一个参数fn，这个fn便是例一中用于实现getUserId的主体功能的代码。跳到Promise实现的最后一行，我们可以看到，创建Promise对象的时候，会以回调函数的形式调用传入方法fn，而fn的参数就是Promise对象内部的方法resolve。至此resolve方法的来源已经秦楚了：resolve是Promise对象的内部方法，功能是触发下一步执行。 Promise对象中deferreds可以简单看做需要异步操作顺序执行的方法队列。继续看Promise对象中resolve方法的具体实现。假设情景是getUserId中IO操作完成，调用resolve方法，此时resolve方法接受参数value并将回调函数队列一一执行。读者很容易就可以发现，如果只执行getUserId()，那么执行resolve触发时，回调队列是空的，没有函数被调用。 接着看Promise对象的then方法，接受一个方法参数onFulfilled，将该函数加入回调队列尾。到这里我们就把最基础的Promise实现全都连上了：调用getUserId –&gt; 以回调函数形式传入匿名函数 –&gt; 调用回调函数IO操作（异步代码加入事件队列尾） –&gt; 返回Promise对象 –&gt; 执行then方法 –&gt; 将IO完成后需要执行的函数加入队列尾 –&gt; IO结束，执行resolve触发 –&gt; 执行deferreds队列中的方法 这就是Promise最基础的实现方式，虽然简单，但是已经将最基本的代码思路给出来了，后续的升级版本也是在这个基础上完善。例如想要传入在一个异步操作执行完成后，执行多个同步方法，只需要稍稍修改then方法就可以达到目的1234this.then = function (onFulfilled) &#123; deferreds.push(onFulfilled); return this;&#125;; 增加延时从之前的叙述可以知道，如果Promise中传入的方法是同步代码，那么执行resolve时then方法还没被调用，这时回调队列其实是空的，而且接下来用then方法注册的回调函数也不会再被调用。，读者可以将下面的代码写入Js解释环境进行验证123456789101112131415161718192021222324252627function fakePromise(fn) &#123; var value = null, deferreds = []; this.then = function (onFulfilled) &#123; deferreds.push(onFulfilled); &#125;; function resolve(value) &#123; deferreds.forEach(function (deferred) &#123; deferred(value); &#125;); &#125; fn(resolve);&#125;function getUserId() &#123; return new fakePromise(function (resolve) &#123; console.log(\"getUserId执行完毕\"); resolve(\"执行回调函数\"); &#125;);&#125;getUserId().then(function (str) &#123; console.log(str);&#125;); 为此，我们需要认为地确保resolve触发动作在then方法之后执行。通过使用setTimeout将resolve执行事件添加到事件队列尾1234567function resolve(value) &#123; setTimeout(function () &#123; deferreds.forEach(function (deferred) &#123; deferred(value); &#125;); &#125;, 0);&#125; 引入状态这一段无话可说 串行Promise原文中这一段有点难度，看着有些绕，看了其他几篇文章，最后也没看到明悟，所以这里按博主自己的理解讲。如果将来出了偏颇的话，我是不负责的 稍加理解就能知道，上面的Promise基本实现的then方法只能接受同步代码，而不能在then方法中传入另一个异步方法，要解决这个问题，需要进一步修改Promise对象。这里贴一下引文中为了衔接当前 promise 和后邻 promise对Promise对象做的修改 1234567891011121314151617181920212223242526272829303132333435this.then = function (onFulfilled) &#123; return new Promise(function (resolve) &#123; handle(&#123; onFulfilled: onFulfilled || null, resolve: resolve &#125;); &#125;);&#125;;function handle(deferred) &#123; if (state === 'pending') &#123; deferreds.push(deferred); return; &#125; var ret = deferred.onFulfilled(value); deferred.resolve(ret);&#125;function resolve(newValue) &#123; if (newValue &amp;&amp; (typeof newValue === 'object' || typeof newValue === 'function')) &#123; var then = newValue.then; if (typeof then === 'function') &#123; then.call(newValue, resolve); return; &#125; &#125; state = 'fulfilled'; value = newValue; setTimeout(function () &#123; deferreds.forEach(function (deferred) &#123; handle(deferred); &#125;); &#125;, 0);&#125; 原文的描述是： then 方法中，创建了一个新的 Promise 实例，并作为返回值，这类 promise，权且称作 bridge promise。这是串行 Promise 的基础。另外，因为返回类型一致，之前的链式执行仍然被支持； handle 方法是当前 promise 的内部方法。这一点很重要，看不懂的童鞋可以去补充下闭包的知识。then 方法传入的形参 onFullfilled，以及创建新 Promise 实例时传入的 resolve 均被压入当前 promise 的 deferreds 队列中。所谓“巧妇难为无米之炊”，而这，正是衔接当前 promise 与后邻 promise 的“米”之所在。 博主当时就是这一段看的有点迷hhh，这里说一下自己的理解。 对then方法传入一个异步方法用作回调时，此时返回一个新的Promise对象，称作bridge Promise。 then方法返回的bridge Promise的resolve方法和传入形参onFullfilled包装为对象被压入当前Promise对象的回调队列。意思就是，当当前Promise异步操作结束后，调用自身的resolve方法，就会通过当前Promise的handle方法执行刚刚生成的bridge Promise传入的onFulilled方法。 而执行的bridge Promise传入的onFulilled方法即是执行另一个异步操作函数，产生一个新的Promise并等待执行。至此，当前和后邻Promise就衔接上了。 失败处理和异常处理这两块如果上面看懂了的话，看看原文的代码应该很快就理解了，这里就不多说了。觉得Promise的前后衔接还是应该是全文最复杂、最难理解的一块了。。 结语这篇个人整理就这样啦，有兴趣（没看懂）的读者可以再看看下面的补充资料～ Promise的前世今生和妙用技巧 理解Promise简单实现的背后原理","categories":[{"name":"JS随笔","slug":"JS随笔","permalink":"http://ghoskno.github.io/categories/JS随笔/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ghoskno.github.io/tags/JavaScript/"},{"name":"js异步编程","slug":"js异步编程","permalink":"http://ghoskno.github.io/tags/js异步编程/"},{"name":"异步流程控制","slug":"异步流程控制","permalink":"http://ghoskno.github.io/tags/异步流程控制/"}]},{"title":"Node.js实现爬虫异步抓取豆瓣图书信息","slug":"douban-spider","date":"2017-03-31T05:48:06.000Z","updated":"2018-04-23T03:55:48.000Z","comments":true,"path":"2017/03/31/douban-spider/","link":"","permalink":"http://ghoskno.github.io/2017/03/31/douban-spider/","excerpt":"本篇介绍Node.js实现爬虫抓取豆瓣图书信息，详细讲解Node.js爬虫的异步流程和并发控制。","text":"本篇介绍Node.js实现爬虫抓取豆瓣图书信息，详细讲解Node.js爬虫的异步流程和并发控制。 前言一个必然的机会，这学期有一个数据结构课设，要用Java实现一个有一定数据处理能力的模拟图书管系统。既然要求了数据处理能力，那数据量自然不能太少，如果自己随机生成一堆abcd的数据又显得比较low，用Node.js写一个爬虫抓取豆瓣上图书信息这个想法咻的一下就出现啦～最后实现的过程有一点点曲折，没一开始咻的那一下想的那么简单hh先把要用到的依赖包简单介绍下 async Async是一个为处理异步Js提供简单、直接、强大功能的实用模块 本文中用到async来处理一组多个链接的内容抓取，处理异步集合流程和并发控制 superagentnodejs里一个非常方便的客户端请求代理模块，非常流行，操作也简单 superagent-proxy一段时间内高频率请求豆瓣页面会被封IP的。。。gg这个时候就需要使用IP代理通过变换IP来怼回去，superagent-proxy就是这么一个加载代理的Node.js模块 cheerio用来将返回上下文转化为可用jQuery操作的模块，包括 jQuery 核心的子集，从jQuery库中去除了所有 DOM不一致性和浏览器尴尬的部分 eventproxy利用事件驱动机制解耦复杂异步逻辑，提升异步协作场景的执行效率。简单说作用就是优雅地处理异步事件流 篇幅原因，本篇着重讲解爬虫的具体实现和个别依赖包的个别API使用 すみません 正文开始分析豆瓣页面结构因为课设对数据的需求仅限于书名、作者、出版社、类别和简介，所以分析了一下之后很容易就找到了方便爬的页面 找到要抓取的目标后，因为本文使用的是cheerio，所以我们通过jQuery的选取元素方式来获取元素。这里可以用Chrome浏览器来获取页面元素的selector。具体操作是，右键检查元素–&gt;Copy–&gt;Copy selector。当然Chrome开发者工具也有Copy XPath的功能，如果喜欢用XPath的话也是可以的，解析Xpath也有相应的模块，这里就不赘述了 引入模块和定义相应变量123456789101112131415161718const request = require(\"superagent\"), async = require('async'), eventproxy = require('eventproxy'), cheerio = require(\"cheerio\"); require(\"superagent-proxy\")(request);const ep = new eventproxy();const fs = require('fs');//抓取分类区块和保存文件名数组的设置var blockCount = 0;const blockName = ['literature', 'popular', 'culture', 'life', 'management', 'technology'];const doubanTagUrl = 'https://book.douban.com/tag/';var TagPageUrl = [], //存放大分类下每个小分类的连接 filteredTagPageUrl = [], //存放过滤后能成功访问的小分类链接 catchData = []; //存放对每个大分类抓取到的数据var blockrow, //记录大分类下小分类的行数 $TagPage; // 存放/tag页面的res.text blockCount和blockName分别是计数和存放豆瓣页面下不同大类图书的变量 抓取标签页内容在上代码之前，把存在的问题说一下，由于豆瓣会对短时间内频繁访问豆瓣的IP封锁一天，小白博主在找不到较好的办法和不想拖慢爬虫速度的情况下决定破财免灾找到了一个比较好用的IP代理服务：阿布云 按小时买代理服务，好用不贵～ 需要引入的superagent-proxy模块和设置代理如下123456// 代理隧道验证信息 const proxyHost = \"proxy.abuyun.com\"; const proxyPort = 9010; const proxyUser = \"abcdefghijklmnop\"; const proxyPass = \"123456789abcdefg\"; const proxyUrl = \"http://\" + proxyUser + \":\" + proxyPass + \"@\" + proxyHost + \":\" + proxyPort; 具体的proxyPort还得看买的服务是什么类型啦，官网文档写的还是挺清楚的 superagent接下来就是实际抓取的函数了，简单说一下superagent的用法一个请求的初始化可以用请求对象里合适的方法来执行，然后调用end()来发送请求,下面是一个简单的get请求1234567const request = require(\"superagent\");const url = 'xxx';request.get(url).end(function(err,res)&#123; /** * 处理返回res **/&#125;)； 所以我们只要在.end( )里加上处理的函数即可 完整抓取标签页内容代码12345678910111213/** * 获取豆瓣分类浏览页面 */ var getDoubanPage = function() &#123; request.get(doubanTagUrl).proxy(proxyUrl).end(function(err, res) &#123; if (err) console.error('访问豆瓣失败，检查IP封锁！'); else &#123; $TagPage = cheerio.load(res.text); getFilteredTagUrl($TagPage); &#125; &#125;); &#125; 获取小分类的标签链接简单分析html结构后，我想出的比较简单的方法是对每一个大分类遍历内部所有小分类，逐次抓取大分类并写入不同文件。处理的过程中，发现的一个问题是，有些小分类链接访问失败，有一定随机性，应该是玄学问题，所以要加上一个过滤链接的函数，如下12345678910111213141516171819202122232425262728293031323334353637383940/** * 获取过滤后可访问的小分类链接 */ var getFilteredTagUrl = function($) &#123; blockrow = parseInt($('#content &gt; div &gt; div.article &gt; div:nth-child(2) &gt; div:nth-child(' + blockCount + 1 + ') &gt; table td').length / 4); for (var i = 1; i &lt;= blockrow; i++) &#123; for (var j = 1; j &lt;= 4; j++) &#123; TagPageUrl.push('https://book.douban.com' + $('#content &gt; div &gt; div.article &gt; div:nth-child(2) &gt; div:nth-child(' + blockCount + 1 + ') &gt; table &gt; tbody &gt; tr:nth-child(' + i + ') &gt; td:nth-child(' + j + ') &gt; a').attr('href')); ep.emit('getUrl', TagPageUrl[TagPageUrl.length - 1]); /** * 获取小类链接后 * 为'getUrl'事件计数器计数 **/ &#125; &#125; /** * 'getUrl'事件达到指定次数，即一获得当前分类下所有小分类链接 * 对小类链接进行确认并处理 * 注册'checkUrl'事件，当所有小类链接确认后，开始收集图书信息 */ ep.after('getUrl', blockrow * 4, function(list) &#123; TagPageUrl.forEach(function(el, index) &#123; console.log(el); request.get(encodeURI(el)).proxy(proxyUrl).end(function(err, res) &#123; ep.emit('checkUrl', el); //为'checkUrl'事件计数器计数 if (err) console.error(el); else &#123; for (var i = 0; i &lt;= 200; i++) &#123; //获取前两百页内容 filteredTagPageUrl.push(el + '?start=' + i * 20 + '&amp;type=T'); &#125; &#125; &#125;); &#125;); //所有'checkUrl'事件结束后，开始收集信息 ep.after('checkUrl', blockrow * 4, getbookstart); &#125;); &#125; 这一段代码要注意的地方比较多，以下逐一说明 观察链接小标签url后会发现，链接是带中文的，在浏览器里访问链接会被浏览器自动解析为百分号编码的通用地址，但是在Node.js爬虫里，我们需要手动做这件事，所以在传入url前要先进行编码，使用JavaScript提供的encodeURI()方法即可 使用eventproxy进行事件流程控制这里用一个没什么卵用的例子来说明 代码中getFilteredTagUrl函数内部的ep.emit(&#39;getUrl&#39;, TagPageUrl[TagPageUrl.length - 1]);简单理解就是为getUrl事件的计数器加一，并将TagPageUrl[TagPageUrl.length - 1]传入事件计数器数组，可将数组作为参数传递给事件结束调用的回调函数 ep.after(&#39;getUrl&#39;, blockrow * 4, function(list){...})简单理解就是ep.after(event, num, handle)中，after方法注册事的件event执行次数达到传入参数num后，调用回调函数handle处理结果 虽然在现在的例子中没有什么卵用，同步执行下顺序操作即可，但是我们也能很容易想到eventproxy事件代理的使用场景：发送请求后异步操作回调 所以当确认链接有效的请求发送后，通过一定次数的触发事件代理的回调函数进入下一步页面抓取，在代码的最后几行，ep.after(&#39;checkUrl&#39;, blockrow * 4, getBookStart)即是当所有小分类链接确认操作完成后，对每一页图书信息进行抓取 这里好像没什么好说的了，但是得凑出个第三点来，不如你门好好看看eventproxy的文档吧 抓取图书信息先说明一下async的用法和主要用途 使用async限制并发访问数量，控制异步流程 mapLimit定义 mapLimit(collection, limit, iteratee(item,callback), callback(err, results)) collection为要操作的元素集合,limit为并发数量 iteratee为操作集合内元素的迭代器，接受参数分别为item和callback,接下来我们看一下官方文档的描述 iteratee - function - A function to apply to each item in coll. The iteratee is passed a callback(err, transformed) which must be called once it has completed with an error (which can be null) and a transformed item. Invoked with (item, callback). 翻译一下，意思就是，迭代器参数列表中必须有callback，这个callback接受的参数为(err,transformed),在每个元素迭代操作完成后都会调用，用于将transformed传递给results，所有迭代器完成后，results会被传递给callback（mapLimit的最后一个参数） 接受的callback为可选参数，会在所有迭代器完成后执行 理解了这些，下面的代码就很容易理解了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var getBookStart = function() &#123; console.log('filteredTagPageUrl:' + filteredTagPageUrl.length); //利用async.mapLimit指定并发数量，调用catchBook获取书本信息 async.mapLimit(filteredTagPageUrl, 5, function(el, callback) &#123; catchBook(el, callback); &#125;, function(err,results) &#123; console.log(\"complete!\"); //所有页面采集任务结束后，等待500ms后将数据写入文件 setTimeout(WriteFile, 500); &#125;); &#125; /** * [catchBook] * @param &#123;String&#125; el [页面url] * @param &#123;Function&#125; callback [mapLimit回调触发] */ var catchBook = function(el, callback) &#123; var delay = parseInt((Math.random() * 30000000) % 1000, 10); //设置延迟时长，模拟人为操作 request.get(encodeURI(el)).proxy(proxyUrl).end(function(err, res) &#123; if (err) console.error('无效链接'); else &#123; var $ = cheerio.load(res.text); for (var i = 1; i &lt;= 20; i++) &#123; //对每页的二十本书进行内容抓取 var bookOP; /** * 利用正则表达式处理抓取信息，这里不赘述 * 欢迎查看github上的源码 */ catchData.push(bookOP); &#125; &#125; &#125;); setTimeout(function() &#123; //触发mapLimit回调 callback(null, el); &#125;, delay); &#125; /** * [WriteFile 写入文件] */ var WriteFile = function() &#123; fs.writeFile('./data/' + blockName[blockCount] + '.txt', catchData, (err) =&gt; &#123; if (err) throw err; else &#123; console.log(blockName[blockCount] + ' is saved!'); if (blockCount + 1 &lt; blockName.length) &#123; //读取下一大类 setTimeout(function() &#123; blockCount++; TagPageUrl = []; filteredTagPageUrl = []; catchData = []; getFilteredTagUrl(); &#125;, 3500); &#125; &#125; &#125;); &#125; 最后的读写文件操作比较简单，也不进行赘述啦～ 结语没什么好结语的啦，可把我累坏了欢迎follow我的githubhhh（虽然没啥东西） 相关资料及工具链接 github地址 SuperAgent中文使用文档 async官方文档 一张图学会使用Async组件进行异步流程控制 superagent-proxy github地址 通读cheerio API IP代理阿布云官网 eventproxy官方文档","categories":[{"name":"小白散步日常","slug":"小白散步日常","permalink":"http://ghoskno.github.io/categories/小白散步日常/"}],"tags":[{"name":"异步流程控制","slug":"异步流程控制","permalink":"http://ghoskno.github.io/tags/异步流程控制/"},{"name":"Node.js","slug":"Node-js","permalink":"http://ghoskno.github.io/tags/Node-js/"},{"name":"async","slug":"async","permalink":"http://ghoskno.github.io/tags/async/"},{"name":"爬虫","slug":"爬虫","permalink":"http://ghoskno.github.io/tags/爬虫/"}]},{"title":"balabala","slug":"balabala","date":"2017-03-21T13:41:45.000Z","updated":"2018-04-23T03:55:48.000Z","comments":true,"path":"2017/03/21/balabala/","link":"","permalink":"http://ghoskno.github.io/2017/03/21/balabala/","excerpt":"","text":"之前的博客因为系统崩了，没做好备份，已经gg。这里就随便balabala两句吧","categories":[{"name":"说明","slug":"说明","permalink":"http://ghoskno.github.io/categories/说明/"}],"tags":[]},{"title":"简单实现仿Vuejs双向绑定","slug":"vue-bind","date":"2017-02-21T14:11:18.000Z","updated":"2018-04-23T03:55:48.000Z","comments":true,"path":"2017/02/21/vue-bind/","link":"","permalink":"http://ghoskno.github.io/2017/02/21/vue-bind/","excerpt":"前言最近看了些关于vue的博客，觉得只懂的用vue的语法糖，却连一点原理都不知道总有点那啥。所以今天整理了一些关于简单实现Vue双向数据绑定的知识～参考资料 Vue.js双向绑定的实现原理 剖析Vue原理&amp;实现双向绑定MVVM","text":"前言最近看了些关于vue的博客，觉得只懂的用vue的语法糖，却连一点原理都不知道总有点那啥。所以今天整理了一些关于简单实现Vue双向数据绑定的知识～参考资料 Vue.js双向绑定的实现原理 剖析Vue原理&amp;实现双向绑定MVVM 正文实现原理基础Vue实现双向数据绑定的做法是数据劫持，个人的理解是将需要绑定的元素进行封装，修改set和get方法，在元素被访问时达到响应绑定的效果。 我们可以先来看一个非常简单的双向绑定实现 12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;input type=\"text\" id=\"a\"&gt; &lt;sapn id=\"b\"&gt;&lt;/sapn&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;var obj = &#123;&#125;;Object.defineProperty(obj, \"bindtext\", &#123; //修改obj对象bindtext属性的set方法 set: function(newVal) &#123; document.getElementById('a').value = newVal; document.getElementById('b').innerHTML = newVal; &#125;&#125;);document.addEventListener('keyup', function(e) &#123; //监听键盘操作，修改 obj.bindtext = e.target.value;&#125;);&lt;/script&gt; 这个例子可已做到对输入框与标签的双向数据绑定，但是为了最后做到如同vue进行双向绑定一样方便，我们还需要做一下对上述步骤的分解和重组。 将输入框及文本节点与data的数据绑定 输入框内容发生变化时，data中的数据同步变化（view=&gt;model） data中数据变化时，同样修改绑定的文本节点（model=&gt;view） 绑定数据DocumentFragment相关这里需要引入一下DocumentFragment的知识，按照我们的思路，对绑定的页面元素进行封装过程会引入很大的消耗，我们需要一种方法来避免对DOM元素的直接封装操作。Vue进行编译时，引入DocumentFragment作为代替容器。DocumentFragment可以简单看作一个节点容器，它可以包裹多个子节点，当整个DocumentFragment插入DOM时，只有其子节点被插入DOM。使用DocumentFragment代替DOM的直接处理，可以提高速度和性能。想详细了解DocumentFragment可以查看DocumentFragment详细说明 封装DOM节点为DocumentFragment的代码如下 123456789101112function convertNode(node, vm) &#123; var fragment = document.createDocumentFragment(); var child; while (child = node.firstChild) &#123; //do something fragment.append(child); &#125; return fragment; &#125;var dom = convertNode(document.getElementById('app'));document.getElementById('app').appendChild(dom); 上面的convertNode函数会将传入node的子节点进行劫持，经过处理后重新挂载回目标节点。 数据绑定初始化简单说明一下这部分的具体思路 首先我们需要一个函数comile负责将目标节点中所有含f-model属性的元素及被双括号包裹的文本内容与对应data绑定。 对需要绑定的目标节点，其子节点的封装过程由上面的convertNode传递。 一个fake-Vue对象作为Model层和ViewModel 代码代码1234&lt;div id=\"app\"&gt; &lt;input type=\"text\" id=\"a\" f-model='text'&gt; &#123;&#123;text&#125;&#125;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344function convertNode(node, fm) &#123; var fragment = document.createDocumentFragment(); var child; while (child = node.firstChild) &#123; compile(child, fm); fragment.append(child); &#125; return fragment;&#125;function compile(node, fm) &#123; var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; if (node.nodeType === 1) &#123; var attr = node.attributes; for (var i = 0; i &lt; attr.length; i++) &#123; if (attr[i].nodeName == 'f-model') &#123; var bindName = attr[i].nodeValue; node.value = fm.data[bindName]; node.removeAttribute('f-model'); &#125; &#125; &#125; if (node.nodeType === 3) &#123; if (reg.test(node.nodeValue)) &#123; var bindName = RegExp.$1.trim(); console.log(RegExp.$1); node.nodeValue = fm.data[bindName]; &#125; &#125;&#125;function fake-Vue(options) &#123; this.data = options.data; var id = options.el; var dom = convertNode(document.getElementById(id), this); document.getElementById(id).appendChild(dom);&#125;var fm = new fake-Vue(&#123; el: 'app', data: &#123; text: 'hello world' &#125; &#125;); 数据响应上面的代码就简单实现了将输入框内容及文本节点内容与数据绑定。下一步要做的就是数据对象的响应式。这里第一步我们需要修改被绑定元素的set和get方法123456789101112131415function observe(obj,fm)&#123; Object.keys(obj).forEach(function(key))&#123; Object.defindPrpperty(obj,key,&#123; get:function()&#123; return obj[key]; &#125; set:function(newVal)&#123; if(newVal == val) return; val = newVal; console.log(val); &#125; &#125;); &#125;&#125; 然后是修改compile方法，为输入框添加事件监听触发1234567891011121314151617181920212223function compile(node, fm) &#123; var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; if (node.nodeType === 1) &#123; //节点类型为元素节点 var attr = node.attributes; //对所有属性进行解析 for (var i = 0; i &lt; attr.length; i++) &#123; if (attr[i].nodeName == 'f-model') &#123; //将元素与数据绑定 var bindName = attr[i].nodeValue; node.addEventListener('input',function(e)&#123; fm.data[bindName] = e.target.value; node.value = fm.data[bindName]; &#125;); node.removeAttribute('f-model'); &#125; &#125; &#125; if (node.nodeType === 3) &#123; //节点类型为文本节点 if (reg.test(node.nodeValue)) &#123; var bindName = RegExp.$1.trim(); node.nodeValue = fm.data[bindName]; &#125; &#125;&#125; 还需要在fakeVue中添加observe调用1234567function fakeVue(options) &#123; this.data = options.data; observe(this.data,this); var id = options.el; var dom = convertNode(document.getElementById(id), this); document.getElementById(id).appendChild(dom);&#125; 做完上述修改，输入框的内容变化的时候，fm对象中的值也会一起被修改。这样就完成了model层向View层的绑定。 应用观察者模式这里我们为了完成View层向Model层的绑定，需要引入观察者模式 Observer Pattern,别名也叫订阅/发布模式。这里简单描述下观察者模式，比较抽象的理解就是观察者模式中包含两种角色：观察者（订阅者）和被观察者（发布者），作为观察者，只要订阅了被观察者的事件，那么当观察者的状态改变时，被观察者需要主动通知观察者，但是观察者后续采取什么动作是与被观察者无关的。基本的实现思想是被观察者维护一个订阅列表，列表中存放观察者的对象或观察者提供的回调方法供被观察者进行通知。当被观察者的状态改变时，只要循环执行列表即可。骄傲javascript中的addEventListener就是向目标元素订阅相关的动作，如1element.addEventListener('click', callback, false); 理解了观察者模式，我们也就容易实现View层向Model层的绑定。把Model层作为被观察者，而页面元素作为相关的观察者。 实现双向绑定实现双向绑定的具体步骤是 在对元素进行编译时，对文本节点包装成Watcher，添加到data相关元素的观察者列表里。Watcher负责更新页面元素。 监听过程中，为所有data属性生成一个主体对象dep，dep中包含需要维护的观察者列表，触发Watcher的更新动作，即作为订阅信息的发布者。留下一个全局的Dep对象用于保存目标元素的相关。 修改observe函数，添加对观察者列表的添加动作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081function Dep() &#123; this.subs = []; //被维护的观察者列表&#125;Dep.prototype = &#123; addSub: function(sub) &#123; //被观察者列表的添加动作 this.subs.push(sub); &#125;, notify: function() &#123; //对观察者列表的所有观察者触发更新 this.subs.forEach(function(sub) &#123; sub.update(); &#125;); &#125;&#125;function Watcher(fm, node, bindname) &#123; //将全局Dep.target设置为当前页面元素node Dep.target = this; //完成watcher的初始化 this.name = bindname; this.node = node; this.fm = fm; this.update(); //初次绑定时进行更新 Dep.target = null; //保证Dep.target唯一&#125;Watcher.prototype = &#123; //对绑定node的更新操作 get: function() &#123; this.value = this.fm.data[this.name]; &#125;, update: function() &#123; this.get(); this.node.nodeValue = this.value; &#125;&#125;function observe(obj, fm) &#123; Object.keys(obj).forEach(function(key) &#123; var val = obj[key]; var dep = new Dep(); Object.defineProperty(obj, key, &#123; get: function() &#123; if (Dep.target) //Dep.target存在，将目标元素添加到当前data属性的观察者列表中 dep.addSub(Dep.target); return val; &#125;, set: function(newVal) &#123; if (newVal == val) return; val = newVal; //data属性被修改，由dep触发view层更新 dep.notify(); console.log(val); &#125; &#125;); &#125;);&#125;function compile(node, fm) &#123; var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; if (node.nodeType === 1) &#123; //节点类型为元素节点 var attr = node.attributes; //对所有属性进行解析 for (var i = 0; i &lt; attr.length; i++) &#123; if (attr[i].nodeName == 'f-model') &#123; //将元素与数据绑定 // node.value = fm.data[bindName]; var bindName = attr[i].nodeValue; node.addEventListener('input', function(e) &#123; fm.data[bindName] = e.target.value; &#125;); node.removeAttribute('f-model'); &#125; &#125; &#125; if (node.nodeType === 3) &#123; //节点类型为文本节点 if (reg.test(node.nodeValue)) &#123; var bindName = RegExp.$1.trim(); // node.nodeValue = fm.data[bindName]; new Watcher(fm, node, bindName); //为该页面元素node生产watcher &#125; &#125;&#125; 可能上面的代码有点难懂，这里贴一张流程图，一图胜千言，应该不难懂的黑色的线代表初始化观察者列表等等，红色的线是活动过程中，Model层的状态改变向View层更新的过程。 结语写完啦写完啦本文的代码和demo扔在了双向数据绑定demo感谢阅读～","categories":[{"name":"JS随笔","slug":"JS随笔","permalink":"http://ghoskno.github.io/categories/JS随笔/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ghoskno.github.io/tags/JavaScript/"},{"name":"Vuejs","slug":"Vuejs","permalink":"http://ghoskno.github.io/tags/Vuejs/"},{"name":"设计模式","slug":"设计模式","permalink":"http://ghoskno.github.io/tags/设计模式/"}]},{"title":"ES6学习笔记","slug":"es6","date":"2016-11-20T12:15:30.000Z","updated":"2018-04-23T03:55:48.000Z","comments":true,"path":"2016/11/20/es6/","link":"","permalink":"http://ghoskno.github.io/2016/11/20/es6/","excerpt":"前言整理一些ES6标准的学习笔记，虽然网上已经很多了，还是想写一些hh文中有大部分参考了阮一峰老师的ECMAScript 6入门","text":"前言整理一些ES6标准的学习笔记，虽然网上已经很多了，还是想写一些hh文中有大部分参考了阮一峰老师的ECMAScript 6入门 正文块级作用域、let和constES6新加入了块级作用域，一个花括号{}就代表一个独立的作用域。简单来说被作用域嵌套时外层代码不会被内层代码块影响。看个简单的例子1234567891011function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if(false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());//ES5 result: I am inside!//ES6 result: I am outside! 再就是let命令了，let命令的作用就是其所声明的变量，仅在其所在代码块内有效。需要注意的是，let不会像var一样声明提前，只能在定义之后使用，之前使用会抛出ReferenceError并且不允许在相同作用域内，重复声明同一个变量。因此，不能在函数内部重新声明参数。12345678var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); //result: 10 12345678var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6]();//result: 6 const命令的作用和限制呢，和其他语言差不多，感觉没啥好说的hh 还有就是var和let、const声明变量对于全局对象属性的不同之处 var命令和function命令声明的全局变量，属于全局对象的属性 let命令、const命令、声明的全局变量，不属于全局对象的属性。 ###变量的解构赋值ES6允许在对变量进行赋值时，按照一定模式从数组和对象中提取值进行赋值，称为解构。解构只能用于数组或对象。 对数组的解构赋值，允许指定默认值 对对象的解构赋值，属性没有次序，要求变量与属性同名（sigoyi）123let [foo, [[bar], baz]] = [1, [[2], 3]];let [x, y='b'] = ['a', undefined]; // x='a', y='b'let &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;; 字符串的扩展——模板字符串模板字符串是增强版的字符串，用反引号（`）标识。 当作普通字符串使用 定义多行字符串 在字符串中嵌入变量使用规则如下： 在模板字符串中嵌入变量，需要将变量名写在${}之中。 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 大括号内部可以进行运算，以及引用对象属性，其中还能调用函数。 1234567891011121314151617// 多行字符串console.log(`string text line 1string text line 2`);// 字符串中嵌入变量var name = \"Bob\", time = \"today\";console.log(`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`);//对象属性var obj = &#123;x: 1, y: 2&#125;;console.log(`$&#123;obj.x + obj.y&#125;`);//函数调用function fn() &#123; return \"Hello World\";&#125;console.log(`foo : $&#123;fn()&#125;`); 其实字符串扩展还有一部分是对字符串处理的增强，多是与字符编码相关的，博主也不是特别熟，这里就不多说了，有兴趣可以参考字符串的扩展 数值的扩展参考数值的扩展(太懒不讲) 数组的扩展ES6中提供了数组推导的方法即利用现有数组生成新数组的简化写法for...of，允许多重循环1234567var a1 = [1, 2, 3, 4];var a2 = [for (i of a1) i * 2];a2 // [2, 4, 6, 8]var years = [ 1954, 1974, 1990, 2006, 2010, 2014 ];[for (year of years) if (year &gt; 2000 &amp;&amp; year &lt; 2010) year];// [ 2006] 还有一些额外的数组处理方法 Array.from可以将两类对象转为真正的数组：类似数组的对象（array-like object，有length属性）和可遍历（iterable）的对象。 Array.of可将一组值转化为数组对象。 实例方法copyWithin可将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。 实例的find方法，用于找出第一个符合条件的数组成员。接受一个回调函数(value, index, arr)=&gt;{}作为参数，对每个元素执行该函数，返回第一个返回值为true的成员。 实例的findIndex方法与find类似，返回成员下标。 数组实例的entries()，keys()和values()方法，返回数组的遍历器对象，keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 扩展运算符...，简而言之扩展运算符可以将数组扩展为以逗号分割的参数列表 123456onsole.log(...[1, 2, 3]) // 1 2 3 console.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5 [...document.querySelectorAll('div')] // [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 函数的扩展 ES6允许为函数的参数设置默认值，使用=形式直接写在参数定义的后面 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。 参数默认值所处的作用域，不是全局作用域，而是函数作用域。 rest运算符...，与扩展运算符为互逆操作，即...+变量名形式与...+数组形式互逆，...变量名必须作为最后一个参数且函数的length属性不包括rest参数 12345678910111213function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10(function(a, ...b) &#123;&#125;).length // 1 箭头函数=&gt;,大家都知道吧hhh，不说了 对象扩展 Symbol、ProxySymbolSymbol是ES6引入的一种新的原始数据类型，表示独一无二的值。目的是从根本上防止属性名的冲突。将Symbol用于对象的属性名，就能保证不会出现同名的属性1234567891011121314151617var mySymbol = Symbol();// 第一种写法var a = &#123;&#125;;a[mySymbol] = 'Hello!';// 第二种写法var a = &#123; [mySymbol]: 'Hello!'&#125;;// 第三种写法var a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: 'Hello!' &#125;);// 以上写法都得到同样结果a[mySymbol] // \"Hello!\" 需要注意的是，Symbol值作为对象属性名时，不能用点运算符具体Symbol.for()、Symbol.keyFor()方法的说明可以参考Symbol Proxy可以简单理解为为对象的访问增加一层代理，对对象的访问都会先经过代理层的拦截给出一个简单的例子123456789101112var person = &#123; name: \"张三\"&#125;;var proxy = new Proxy(person, &#123; get: function(target, property) &#123; return property in target ? target[property] : \"不存在的\"; &#125;&#125;);proxy.name // \"张三\"proxy.title // \"不存在的\" 具体Proxy可拦截的操作可参考Proxy概述 Generator函数还是贴一下参考资料好了，人家写的是真好Generator 函数 结语这篇好像贴别人的参考有点多哈没关系，重在参与～","categories":[{"name":"JS随笔","slug":"JS随笔","permalink":"http://ghoskno.github.io/categories/JS随笔/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ghoskno.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://ghoskno.github.io/tags/ES6/"}]},{"title":"HTML5 canvas制作动态随机星图","slug":"canvas-star","date":"2016-09-23T10:29:37.000Z","updated":"2018-04-23T03:55:48.000Z","comments":true,"path":"2016/09/23/canvas-star/","link":"","permalink":"http://ghoskno.github.io/2016/09/23/canvas-star/","excerpt":"本篇将会介绍如何用canvas制作动态随机移动的星图啦啦啦","text":"本篇将会介绍如何用canvas制作动态随机移动的星图啦啦啦 小白在远离小白道路上的第一步就是搭个博客 前言这次的博文不是接着进行博客布置的教学了，对的，我弃坑了，也许以后会回来补用HMTL5+canvas画东西也很好玩嘛，来来来，我们来画那种会随机动来动去的星图。先展示一个demo demo访问地址：动态星图demo 准备在开始这个动态星图的制作前，我希望你能对canvas和它的常用API有一定的了解，在这里给出一份速成教程，四十分钟到一小时可以看完，初步掌握canvas常用API的使用HTML5- Canvas入门（一）HTML5- Canvas入门（二）HTML5- Canvas入门（三）HTML5- Canvas入门（四）HTML5- Canvas入门（五）HTML5- Canvas入门（六）HTML5- Canvas入门（七） 这一段就叫它正文好了首先建立html文件12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;canvas star demo&lt;/title&gt; &lt;style type=\"text/css\"&gt; body&#123; text-align: center; overflow: hidden; background: #C4C6C8; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=\"mycanvas\"&gt;&lt;/canvas&gt;&lt;/body&gt;&lt;/html&gt; 因为我假定你已经有基础或者已经看完了我贴在上面的速成教程，这一段代码就不加以赘述了，接下来是js代码的编写 变量的定义12345678910var width = window.innerWidth, height = window.innerHeight, //获取浏览器视窗的尺寸 amount = 50; //出现在画布上的星星个数var cs = document.getElementById('mycanvas'),//获得canvas元素 cont = cs.getContext('2d'); //对canvas元素进行2d渲染，此后的对画布操作即对cont的操作cs.width = width;cs.height = height; //设置canvas元素的尺寸为浏览器视窗的尺寸cont.strokeWidth = 1; //设置描边宽度 这一段代码设置了基本的样式和尺寸，接下来就是着手制作星团了 星团对象的定义要完成星团对象的定义，我们可以先对想要达到的效果进行逐步分析、拆解，再对其内部属性和方法进行不断完善 先做一个不会动的星团，星团里的所有星星需要一个数组来存储，数组里存储的应该是星星的圆心坐标 需要有一个画星星的方法，就命名为drawStar好了 在demo里看到每个星星都连着其他星星，好带感，所以需要一个画线的方法，就将画线的方法命名为drawLine，连线的方法命名为linkStar好了 每个星星的出现的位置应该是随机的，需要一个产生合适随机数的方法，但是这个方法也许不单单用来产生随机位置，还有随机半径等等，所以就钦定为randomNum吧 这里需要一个方法将上面的几个工具方法组合起来，绘制出完整的星图，不是很会起名了，就叫initStars好了，尽管不是很顺口 以上几个方法足够产生一个静态的随机星图了，要让它动起来的话，还需要一个能够让星图动起来的方法，对的，moveStars 到这里的话，已经初步将对象里需要的方法和属性定义好了，接下来是一步步地实现 属性和各工具方法的定义1234567891011121314151617181920212223242526272829303132333435var Stars = &#123; starArr: [], //定义星团数组 drawStar: function(cxt,x,y,r)&#123; //cxt为传入的画布对象，(x,y)为星星的圆心坐标，r为星星的半径 cxt.beginPath(); //创建路径 cxt.arc(x,y,r,0,2*Math.PI); //画一个圆 cxt.closePath(); //闭合路径 cxt.fill(); //填充 return&#123;x:x,y:y,r:r&#125;; //返回圆心坐标和半径的对象 &#125;, drawLine: function(cxt,x,y,ex,ey)&#123; //(x,y),(ex,ey)分别为线段的起点和终点坐标 cxt.beginPath(); cxt.strokeStyle = \"rgba(0,0,0,1)\";//为线段定义描边样式 cxt.moveTo(x,y); cxt.lineTo(ex,ey); cxt.closePath(); cxt.stroke(); //描边 &#125;, randomNum: function(max,min)&#123; return Math.floor(Math.random()*(max-min+1)+min); //完成基本的产生范围内随机数的要求 &#125;, linkStar: function()&#123; var pStars = this; //创建指针指向调用该方法的Stars对象 for(let i = 0;i &lt; amount;i++)&#123; for(let j = 0;j &lt; amount &amp;&amp; i+j &lt; amount;j++)&#123; pStars.drawLine(cont, pStars.starArr[i+j].x,pStars.starArr[i+j].y, pStars.starArr[i].x,pStars.starArr[i].y) &#125; &#125; &#125;, ...&#125; 到这一步，我们已经把Stars对象里需要用到的工具方法的定义工作完成了 完成星图的静态模型到这里，我们再整理一遍这个方法需要完成的功能：组合各个工具函数绘制出静态的星图代码如下1234567891011121314151617var Stars = &#123; ... initStars: function(cont)&#123; var pStars = this; pStars.starArr = []; //初始化为空数组 cont.clearRect(0,0,cs.width,cs.height);//顺手清理画布 for(let i = 0;i &lt; amount;i++)&#123; pStars.starArr.push(pStars.drawStar(cont, pStars.randomNum(width,0), //随机生成星星的横坐标 pStars.randomNum(height,0), //随机生成星星的纵坐标 pStars.randomNum(2,15) //随机生成星星的半径 )); //返回对象&#123;x:x,y:y,r:r&#125;到starArr &#125; pStars.linkStar(); //连线 &#125;,&#125; 按上述步骤简单组织后，效果如图所示如果你的和我的不一样，那你肯定哪里出问题了。。 美化这个静态星图的效果很惊悚没错。。需要稍微美化一下。。首先，在js代码的头部定义变量处加入1cont.fillStyle = \"rgba(0,0,0,0.05)\"; //设置填充样式 接着，修改线段的颜色深浅，我们希望每条线段有不同的深浅度，最好是和线段的长度存在一定关系 先修改方法drawLine 123456789drawLine: function(cxt,x,y,ex,ey,o)&#123; //(x,y),(ex,ey)分别为线段的起点和终点坐标,o为透明度 cxt.beginPath(); cxt.strokeStyle = 'rgba(0,0,0,'+o+')';//为线段定义描边样式 cxt.moveTo(x,y); cxt.lineTo(ex,ey); cxt.closePath(); cxt.stroke(); //描边&#125; 修改方法linkStar 123456789101112131415linkStar: function()&#123; var pStars = this; //创建指针指向调用该方法的Stars对象 for(let i = 0;i &lt; amount;i++)&#123; for(let j = 0;j &lt; amount &amp;&amp; i+j &lt; amount;j++)&#123; var xx = Math.abs(pStars.starArr[i+j].x - pStars.starArr[i].x), yy = Math.abs(pStars.starArr[i+j].y - pStars.starArr[i].y), line = Math.sqrt(xx*xx,yy*yy), o = 1/line*7-0.009; o= o &gt; 0.05 ? 0.05 :o; pStars.drawLine(cont, pStars.starArr[i+j].x,pStars.starArr[i+j].y, pStars.starArr[i].x,pStars.starArr[i].y,o) &#125; &#125;&#125; 修改之后，会呈现如下图效果 完成星图的动态模型接下来就是制作动态星图的模型了，要实现canvas的动画效果，普遍的做法是在经过一定时间间隔后进行重绘。如此，一个较为简单且容易想到的思路就出现了，经过初始化后的静态星图模型已经将所有星星的的坐标存放于数组starArr中，只需要在清理画布后，将数组内的坐标加上适当偏移后绘制出来，即可达到想要的动态效果。为此，我们需要在对象数组starArr中为对象添加其他属性1234567891011var Stars = &#123; ... moveStars: function()&#123; var pStars = this; for(let i = 0;i &lt; amount;i++)&#123; pStars.starArr[i].moveX = pStars.randomNum(10,-10)/40; pStars.starArr[i].moveY = pStars.randomNum(10,-10)/40; &#125; ... &#125;&#125; 上面的代码已经为对象数组中的元素添加了新的属性，即偏移量，接下来就是设置定时器使星图重绘了12345678910111213141516171819var Stars = &#123; ... moveStars: function()&#123; ... setInterval(function()&#123; cont.clearRect(0,0,cs.width,cs.height); //清理 for(let i = amount - 1;i &gt;= 0;i--)&#123; var star = pStars.starArr[i]; star.x += star.moveX; star.y += star.moveY; //完成偏移 star.x &lt; 0 ? (star.x = cs.width) : (star.x &gt; cs.width ? star.x = 0 : ''); star.y &lt; 0 ? (star.y = cs.height) : (star.y &gt; cs.height ? star.y = 0 : ''); Stars.drawStar(cont,star.x,star.y,star.r); &#125; Stars.linkStar(); &#125;,50) &#125;&#125; 至此，就已经将对象的方法和属性全定义完啦，最后一步就是组织js函数调用这个对象 调用1234window.onload = function()&#123; Stars.initStars(cont); Stars.moveStars();&#125; 组合之后，就能够显示出动态星图的效果啦 美化二本来想做美化的，做成真正星星那样，但是好麻烦啊，先留着坑，有空再做好了(其实后来作者弃坑了，被繁重的学业压垮了脊梁) 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;canvas star demo&lt;/title&gt; &lt;style type=\"text/css\"&gt; body &#123; text-align: center; overflow: hidden; background: #C4C6C8; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=\"mycanvas\"&gt;&lt;/canvas&gt; &lt;script type=\"text/javascript\"&gt; var width = window.innerWidth, height = window.innerHeight, //获取浏览器视窗的尺寸 amount = 50; //出现在画布上的星星个数 var cs = document.getElementById('mycanvas'), //获得canvas元素 cont = cs.getContext('2d'); //对canvas元素进行2d渲染，此后的对画布操作即对cont的操作 cs.width = width; cs.height = height; //设置canvas元素的尺寸为浏览器视窗的尺寸 cont.fillStyle = \"rgba(0,0,0,0.15)\"; //设置填充样式 cont.strokeWidth = 1; //设置描边宽度 var Stars = &#123; starArr: [], //定义星团数组 drawStar: function(cxt, x, y, r) &#123; //cxt为传入的画布对象，(x,y)为星星的圆心坐标，r为星星的半径 cxt.beginPath(); //创建路径 cxt.arc(x, y, r, 0, 2 * Math.PI); //画一个圆 cxt.closePath(); //闭合路径 cxt.fill(); //填充 return &#123; x: x, y: y, r: r &#125;; //返回圆心坐标的对象 &#125;, drawLine: function(cxt, x, y, ex, ey, o) &#123; //(x,y),(ex,ey)分别为线段的起点和终点坐标,o为透明度 cxt.beginPath(); cxt.strokeStyle = 'rgba(0,0,0,' + o + ')';//为线段定义描边样式 cxt.moveTo(x, y); cxt.lineTo(ex, ey); cxt.closePath(); cxt.stroke(); //描边 &#125;, randomNum: function(max, min) &#123; return Math.floor(Math.random() * (max - min + 1) + min); //完成基本的产生范围内随机数的要求 &#125;, linkStar: function() &#123; var pStars = this; //创建指针指向调用该方法的Stars对象 for (let i = 0; i &lt; amount; i++) &#123; for (let j = 0; j &lt; amount &amp;&amp; i + j &lt; amount; j++) &#123; var xx = Math.abs(pStars.starArr[i + j].x - pStars.starArr[i].x), yy = Math.abs(pStars.starArr[i + j].y - pStars.starArr[i].y), line = Math.sqrt(xx * xx, yy * yy), o = 1 / line * 7 - 0.009; o = o &gt; 0.05 ? 0.05 : o; pStars.drawLine(cont, pStars.starArr[i + j].x, pStars.starArr[i + j].y, pStars.starArr[i].x, pStars.starArr[i].y, o) &#125; &#125; &#125;, initStars: function(cont) &#123; var pStars = this; pStars.starArr = []; //初始化为空数组 cont.clearRect(0, 0, cs.width, cs.height);//顺手清理画布 for (let i = 0; i &lt; amount; i++) &#123; pStars.starArr.push(pStars.drawStar(cont, pStars.randomNum(width, 0), pStars.randomNum(height, 0), pStars.randomNum(2, 15))); //返回对象&#123;x:x,y:y&#125;到starArr &#125; pStars.linkStar(); //连线 &#125;, moveStars: function() &#123; var pStars = this; for (let i = 0; i &lt; amount; i++) &#123; pStars.starArr[i].moveX = pStars.randomNum(10, -10) / 40; pStars.starArr[i].moveY = pStars.randomNum(10, -10) / 40; &#125; setInterval(function() &#123; cont.clearRect(0, 0, cs.width, cs.height); for (let i = amount - 1; i &gt;= 0; i--) &#123; var star = this.Stars.starArr[i]; star.x += star.moveX; star.y += star.moveY; //完成偏移 star.x &lt; 0 ? (star.x = cs.width) : (star.x &gt; cs.width ? star.x = 0 : ''); star.y &lt; 0 ? (star.y = cs.height) : (star.y &gt; cs.height ? star.y = 0 : ''); Stars.drawStar(cont, star.x, star.y, star.r); &#125; Stars.linkStar(); &#125;, 50); &#125; &#125; window.onload = function() &#123; Stars.initStars(cont); Stars.moveStars(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结语123456789101112function Achievement()｛ count: 0; addBlog: function() &#123; count++; &#125; log: function(str) &#123; console.log(str); &#125;｝var 人生成就 = new Achievement();人生成就.addBlog();人生成就.log(\"前端博客++\");","categories":[{"name":"小白散步日常","slug":"小白散步日常","permalink":"http://ghoskno.github.io/categories/小白散步日常/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://ghoskno.github.io/tags/HTML5/"},{"name":"canvas","slug":"canvas","permalink":"http://ghoskno.github.io/tags/canvas/"}]}]}